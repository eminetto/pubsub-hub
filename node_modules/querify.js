/**
*    Copyright (C) 2008 Ian Jørgensen, Mathias Buus Madsen.
*
*    This program is free software: you can redistribute it and/or  modify
*    it under the terms of the GNU Affero General Public License, version 3,
*    as published by the Free Software Foundation.
*
*    This program is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*    GNU Affero General Public License for more details.
*
*    You should have received a copy of the GNU Affero General Public License
*    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

var push = function(list, item) { // simple linked list impl for performance
	if (!list) {
		item.list = item;
		return item;
	}
	list.next = item;
	item.list = list.list;

	return item;
};
var isRegex = function(regex) {
	return Object.prototype.toString.call(regex) === '[object RegExp]';
};
var reduce = function(op, a) { // this method is verbose and built for speed
	a = a.list;

	if (!a.next) { // single item track
		delete a.list;
		return a;
	}
	if (!a.next.next) { // fast op track
		var b = a.next;

		return op === 'and' ?
			function(doc) {
				return a(doc) && b(doc);
			} :
			function(doc) {
				return a(doc) || b(doc);
			};
	}
	return op === 'and' ?  // list iteration track
		function(doc) {
			for (var next = a; next; next = next.next) {
				if (!next(doc)) {
					return false;
				}
			}
			return true;
		} :
		function(doc) {
			for (var next = a; next; next = next.next) {
				if (next(doc)) {
					return true;
				}
			}
			return false;			
		};
};
var reduceArray = function(op, arr, fn) { // basicly just sugar for turning an array into a linked-list and reducing
	var list;
	
	if (Array.isArray(arr)) {
		for (var i = 0; i < arr.length; i++) {
			list = push(list, fn(arr[i]));
		}
	} else {
		list = push(list, fn(arr));
	}
	
	return reduce(op, list);
};

// the outer language: doc:{$op:value}
var outer = {
	$has: function(keys) {
		return reduceArray('and', keys, function(key) {
			return function(doc) {
				return key in doc;
			};
		});
	},
	$or: function(paths) {
		return reduceArray('or', paths, compile);
	}
};

// the inner language: doc:{key:{$op:value}}
var inner = {
	$not: function(key, val) {
		if (isRegex(val)) {
			var fn = inner.$regex(key, val);
			
			return function(doc) {
				return !fn(doc);
			};
		}
		return function(doc) {
			return doc[key] !== val;
		};
	},
	$exists: function(key, val) {
		return function(doc) {
			return (key in doc) === val;
		};
	},
	$nil: function(key, val) {
		return function(doc) {
			return (doc[key] === undefined || doc[key] === null) === val;
		};
	},
	$any: function(key, vals) {
		return reduceArray('or', vals, function(val) {
			return function(doc) {
				return doc[key] === val;
			};
		});
	},
	$like: function(key, vals) {
		return reduceArray('and', vals, function(val) {
			return function(doc) {
				return typeof doc[key] === 'string' && doc[key].toLowerCase().indexOf(val) > -1;				
			};
		});
	},
	$regex: function(key, regex) { // normalized syntax for regex queries
		if (typeof regex === 'string') {
			var index = regex.lastIndexOf('/');
			var modifiers = regex.substring(index+1);

			regex = new RegExp(regex.substring(1,index), modifiers);
		}
		return function(doc) {
			return doc[key] !== undefined && doc[key] !== null && regex.test(doc[key]);
		};
	},
	// classic number operators
	$gt: function(key, val) {
		return function(doc) {
			return doc[key] > val;
		};
	},
	$gte: function(key, val) {
		return function(doc) {
			return doc[key] >= val;
		};
	},
	$lt: function(key, val) {
		return function(doc) {
			return doc[key] < val;
		};
	},
	$lte: function(key, val) {
		return function(doc) {
			return doc[key] <= val;
		};
	},
	$mod: function(key, val) {
		return function(doc) {
			return doc[key] % val[0] === val[1];
		};
	},
	$datetime: function(key, val) {
		var template = /^(?:(mon|tue|wed|thu|fri|sat|sun)\w*)?,?\s*(\d{1,2}(?:[^:0-9]|$))?\s*([a-z]+)?\s*(\d{4})?\s*([\d|-]{1,2}:[\d|-]{1,2}:[\d|-]{1,2})?\s*([+-]\d*\.?\d+)?/i;		
		var matches = val.match(template);

		if (!matches) {
			return function() {
				return false;
			};
		}

		matches = matches.slice(1);

		var map = {};

		matches[0] && (map.getUTCDay = ['sun','mon','tue','wed','thu','fri','sat'].indexOf(matches[0].substring(0, 3).toLowerCase()));
		matches[1] && (map.getUTCDate = parseInt(matches[1], 10));
		matches[2] && (map.getUTCMonth = ['jan','feb','mar','apr','may','jun','jul','aug','sep','oct','nov','dec'].indexOf(matches[2].substring(0,3).toLowerCase()));
		matches[3] && (map.getUTCFullYear = parseInt(matches[3], 10));

		var time = matches[4] && matches[4].split(':');
		
		if (time) {
			time[0] !== '--' && (map.getUTCHours = parseInt(time[0], 10));
			time[1] !== '--' && (map.getUTCMinutes = parseInt(time[1], 10));
			time[2] !== '--' && (map.getUTCSeconds = parseInt(time[2], 10));
		}
		var offset = Math.round(Number(matches[5] || 0) * 60);
		
		return function(doc) {
			var date = doc[key];

			if (!date) {
				return false;
			}
			if (typeof date === 'string') {
				date = new Date(date);
			}

			if (offset) {
				date = new Date(date.getTime() + 60000 * offset);
			}
						
			for (var method in map) {

				if (date[method]() !== map[method]) {
					return false;
				}
			}
			return true;
		};
	}
};

// lets add all the "$not"s
[inner, outer].forEach(function(col) {
	for (var i in col) {
		col['$not'+i.substring(1)] = function(i) {
			return function(a,b) {
				var fn = col[i](a,b);

				return function(doc) {
					return !fn(doc);
				};
			};
		}(i);
	}	
});

var compile = function(query) {
	var subset = {};
	var list;
	
	list = push(list, function(doc) {
		for (var i in subset) {
			if (subset[i] !== doc[i]) {
				return false;
			}
		}
		return true;
	});
	
	for (var i in query) {
		var val = query[i];

		if (isRegex(val)) { // shorthand for regex
			list = push(list, inner.$regex(i, val));
			continue;
		}
		if (outer[i]) {
			list = push(list, outer[i](val));
			continue;
		}
		if (typeof val === 'object') {
			for (var j in val) {
				if (inner[j]) {
					list = push(list, inner[j](i, val[j]));
				}
			}
			continue;
		}
		if (i.charAt(0) !== '$') {
			subset[i] = val;			
		}
	}

	return reduce('and', list);
};

exports.compile = compile;

// some nice utilities :)

exports.filter = function() {
	var select = function(obj, sel) {
		if (!sel) {
			return obj;
		}
		var res = {};
		
		for (var i in sel) {
			if (sel[i]) {
				res[i] = obj[i];
			}
		}
		return res;
	};

	return function(array, options) {
		var result = [];
		var query = compile(options.query || {});
		
		if (typeof options.sortBy === 'string') {
			var sort = {};
			
			sort[options.sortBy] = 1;
			options.sortBy = sort;		
		}
		if (options.sortBy) {
			array = array.sort(function(a,b) {
				for (var i in options.sortBy) {
					if (a[i] == b[i]) {
						return 0;
					}
					return options.sortBy[i] * (a[i] > b[i] ? 1 : -1);
				}
			});
		}
		
		for (var i = 0; i < array.length; i++) {
			if (query(array[i])) {
				result.push(select(array[i], options.select));			
			}
		}
	
		return result;
	}
}();

/*
var query = {
	abe: {$nil:true},
	bar: {$mod:[4,0]},
	foo: {$exists:false},
	$or: [{
		baz: 42
	}, {
		baz: 44
	}]
};
var doc = {
	abe: null,
	bar: 4,
	baz: 44
};


console.log(compile(query)(doc));
var subject = new Date('august 22 2011 10:30:00');
console.log(compile({time:{$datetime:'monday'}})({time:subject}));
*/