var push = function(list, item) { // simple linked list impl for performance
	if (!list) {
		item.list = item;
		return item;
	}
	list.next = item;
	item.list = list.list;

	return item;
};
var isRegex = function(regex) {
	return Object.prototype.toString.call(regex) === '[object RegExp]';
};
var reduce = function(op, a) { // this method is verbose and built for speed
	a = a.list;

	if (!a.next) { // single item track
		delete a.list;
		return a;
	}
	if (!a.next.next) { // fast op track
		var b = a.next;

		return op === 'and' ?
			function(doc) {
				return a(doc) && b(doc);
			} :
			function(doc) {
				return a(doc) || b(doc);
			};
	}
	return op === 'and' ?  // list iteration track
		function(doc) {
			for (var next = a; next; next = next.next) {
				if (!next(doc)) {
					return false;
				}
			}
			return true;
		} :
		function(doc) {
			for (var next = a; next; next = next.next) {
				if (next(doc)) {
					return true;
				}
			}
			return false;			
		};
};
var reduceArray = function(op, arr, fn) { // basicly just sugar for turning an array into a linked-list and reducing
	var list;
	
	if (Array.isArray(arr)) {
		for (var i = 0; i < arr.length; i++) {
			list = push(list, fn(arr[i]));
		}
	} else {
		list = push(list, fn(arr));
	}
	
	return reduce(op, list);
};

// the outer language: doc:{$op:value}
var outer = {
	$has: function(keys) {
		return reduceArray('and', keys, function(key) {
			return function(doc) {
				return key in doc;
			};
		});
	},
	$or: function(paths) {
		return reduceArray('or', paths, compile);
	}
};

var DAYS = {sun:0,mon:1,tue:2,wed:3,thu:4,fri:5,sat:6};
var MONTHS = {jan:0,feb:1,mar:2,apr:3,may:4,jun:5,jul:6,aug:7,sep:8,oct:9,nov:10,dec:11};
var DATETIME_PATTERN = /^(?:(mon|tue|wed|thu|fri|sat|sun)\w*)?\s*(\d{1,2})?\s*(?:(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*)?\s*(\d{4})?\s*(?:(\d{1,2})h)?\s*(?:(\d{1,2})m)?\s*(?:(\d{1,2})s)?\s*([+-]\d*\.?\d+)?\s*$/i;

// the inner language: doc:{key:{$op:value}}
var inner = {
	$not: function(key, val) {
		if (isRegex(val)) {
			var fn = inner.$regex(key, val);
			
			return function(doc) {
				return !fn(doc);
			};
		}
		return function(doc) {
			return doc[key] !== val;
		};
	},
	$exists: function(key, val) {
		return function(doc) {
			return (key in doc) === val;
		};
	},
	$nil: function(key, val) {
		return function(doc) {
			return (doc[key] === undefined || doc[key] === null) === val;
		};
	},
	$any: function(key, vals) {
		return reduceArray('or', vals, function(val) {
			return function(doc) {
				return doc[key] === val;
			};
		});
	},
	$like: function(key, vals) {
		return reduceArray('and', vals, function(val) {
			return function(doc) {
				return typeof doc[key] === 'string' && doc[key].toLowerCase().indexOf(val) > -1;				
			};
		});
	},
	$regex: function(key, regex) { // normalized syntax for regex queries
		if (typeof regex === 'string') {
			var index = regex.lastIndexOf('/');
			var modifiers = regex.substring(index+1);

			regex = new RegExp(regex.substring(1,index), modifiers);
		}
		return function(doc) {
			return doc[key] !== undefined && doc[key] !== null && regex.test(doc[key]);
		};
	},
	// classic number operators
	$gt: function(key, val) {
		return function(doc) {
			return doc[key] > val;
		};
	},
	$gte: function(key, val) {
		return function(doc) {
			return doc[key] >= val;
		};
	},
	$lt: function(key, val) {
		return function(doc) {
			return doc[key] < val;
		};
	},
	$lte: function(key, val) {
		return function(doc) {
			return doc[key] <= val;
		};
	},
	$mod: function(key, val) {
		return function(doc) {
			return doc[key] % val[0] === val[1];
		};
	},
	$datetime: function(key, val) {
		var match = val.match(DATETIME_PATTERN);
		
		if (!match) {
			return function() { 
				return false;
			};
		}

		var time = {
			day:DAYS[match[1] && match[1].toLowerCase()],
			date:match[2] && parseInt(match[2],10),
			month:MONTHS[match[3] && match[3].toLowerCase()],
			year:match[4] && parseInt(match[4],10) - 1900,	
			hour:match[5] && parseInt(match[5],10),
			minute:match[6] && parseInt(match[6],10),
			second:match[7] && parseInt(match[7],10),
			timeoffset:match[8] && Math.round(Number(match[8]) * 60)
		};
		
		return function(doc) {
			var date = doc[key];
			
			if (typeof date === 'string') {
				date = new Date(date);
			}
			if (time.timeoffset && date.getTimezoneOffset() !== time.timeoffset) {
				date = new Date(date.getTime() + 60000 * (date.getTimezoneOffset() + time.timeoffset));
			}

			if (time.day !== undefined && date.getDay() !== time.day) {
				return false;
			}
			if (time.date && date.getDate() !== time.date) {
				return false;
			}
			if (time.month && date.getMonth() !== time.month) {
				return false;
			}
			if (time.year && date.getYear() !== time.year) {
				return false;
			}
			if (time.hour !== undefined && date.getHours() !== time.hour) {
				return false;
			}
			if (time.minute !== undefined && date.getMinutes() !== time.minute) {
				return false;
			}
			if (time.second !== undefined && date.getSeconds() !== time.second) {
				return false;
			}
			return true;
		};
	}
};

// lets add all the "$not"s
[inner, outer].forEach(function(col) {
	for (var i in col) {
		col['$not'+i.substring(1)] = function(i) {
			return function(a,b) {
				var fn = col[i](a,b);

				return function(doc) {
					return !fn(doc);
				};
			};
		}(i);
	}	
});

var compile = function(query) {
	var subset = {};
	var list;
	
	list = push(list, function(doc) {
		for (var i in subset) {
			if (subset[i] !== doc[i]) {
				return false;
			}
		}
		return true;
	});
	
	for (var i in query) {
		var val = query[i];

		if (isRegex(val)) { // shorthand for regex
			list = push(list, inner.$regex(i, val));
			continue;
		}
		if (outer[i]) {
			list = push(list, outer[i](val));
			continue;
		}
		if (typeof val === 'object') {
			for (var j in val) {
				if (inner[j]) {
					list = push(list, inner[j](i, val[j]));
				}
			}
			continue;
		}
		if (i.charAt(0) !== '$') {
			subset[i] = val;			
		}
	}

	return reduce('and', list);
};

exports.compile = compile;

// some nice utilities :)

exports.filter = function() {
	var select = function(obj, sel) {
		if (!sel) {
			return obj;
		}
		var res = {};
		
		for (var i in sel) {
			if (sel[i]) {
				res[i] = obj[i];
			}
		}
		return res;
	};

	return function(array, options) {
		var result = [];
		var query = compile(options.query || {});
		
		if (typeof options.sortBy === 'string') {
			var sort = {};
			
			sort[options.sortBy] = 1;
			options.sortBy = sort;		
		}
		if (options.sortBy) {
			array = array.sort(function(a,b) {
				for (var i in options.sortBy) {
					if (a[i] == b[i]) {
						return 0;
					}
					return options.sortBy[i] * (a[i] > b[i] ? 1 : -1);
				}
			});
		}
		
		for (var i = 0; i < array.length; i++) {
			if (query(array[i])) {
				result.push(select(array[i], options.select));			
			}
		}
	
		return result;
	}
}();

/*
var query = {
	abe: {$nil:true},
	bar: {$mod:[4,0]},
	foo: {$exists:false},
	$or: [{
		baz: 42
	}, {
		baz: 44
	}]
};
var doc = {
	abe: null,
	bar: 4,
	baz: 44
};


console.log(compile(query)(doc));
var subject = new Date('august 22 2011 10:30:00');
console.log(compile({time:{$datetime:'monday'}})({time:subject}));
*/